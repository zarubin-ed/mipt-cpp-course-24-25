# CowString

**CowString** – класс для работы со строковыми данными, аналогичный `std::string` с поддержкой оптимизации Copy-on-Write (COW). Управление динамической памятью осуществляется вручную без использования стандартных контейнеров.

---

## Конструкторы

### CowString()
- Выделяет память для строки с емкостью, равной значению константы `kServiceInformationByteLen`.
- Устанавливает счётчик ссылок в `1`.
- Инициализирует строку завершающим нулевым символом.

### CowString(const char* cStyleString)
- Принимает указатель на нуль-терминированную строку.
- Вычисляет длину строки с помощью `strlen()`.
- Выделяет память с учетом дополнительной служебной информации.
- Копирует содержимое исходной строки с использованием `std::copy`.
- Устанавливает счётчик ссылок в `1`.
- Завершает строку символом `\0`.

### CowString(size_t length, char symbol)
- Выделяет память с учетом служебной информации.
- Заполняет строку символом `symbol` с использованием `std::fill`.
- Устанавливает счётчик ссылок в `1`.
- Завершает строку символом `\0`.

### CowString(char symbol)
- Делегирует вызов конструктору `CowString(size_t, char)` с длиной `1`.

### CowString(const CowString& other)
- Поверхностно копирует данные объекта `other` (указатель на буфер, размер и ёмкость).
- Увеличивает счётчик ссылок.

> **Примечание:** Приватный конструктор `CowString(const char*, size_t)` используется для создания подстрок (см. метод `substr`).

---

## Деструктор

### ~CowString()
- Если счётчик ссылок равен `1`, освобождает память посредством `delete[]`.
- Иначе, уменьшает счётчик ссылок.

---

## Методы доступа к данным

### char* data()
- Возвращает указатель на изменяемый массив символов (без служебной информации).
- Перед возвратом вызывает внутренний метод `make_copy()` для обеспечения уникального владения.

### const char* data() const
- Возвращает указатель на неизменяемый массив символов (без служебной информации).

### size_t length() const
- Возвращает количество символов в строке (без завершающего символа).

### size_t size() const
- Идентичен `length()`.

### size_t capacity() const
- Возвращает ёмкость буфера (без учета служебной информации).

### bool empty() const
- Возвращает `true`, если строка пуста, иначе `false`.

---

## Методы доступа к элементам

### char& operator[](size_t i)
- Возвращает ссылку на символ по индексу `i`.
- Перед модификацией вызывает `make_copy()` для обеспечения уникальности буфера.

### const char& operator[](size_t i) const
- Возвращает константную ссылку на символ по индексу `i`.

### char& front() / const char& front() const
- Возвращают ссылку на первый символ строки.
- Неконстантная версия вызывает `make_copy()`.

### char& back() / const char& back() const
- Возвращают ссылку на последний символ строки.
- Неконстантная версия вызывает `make_copy()`.

---

## Методы модификации строки

### void push_back(char symbol)
- Добавляет символ `symbol` в конец строки.
    - Если емкость недостаточна, вызывает метод `reallocate()` с новой емкостью: `kServiceInformationByteLen + (length_ + 1) * 2`.
    - Иначе, перед модификацией вызывается `make_copy()`.
- Увеличивает длину строки и записывает завершающий символ `\0`.

### void pop_back()
- Удаляет последний символ строки.
    - Перед модификацией вызывает `make_copy()`.
    - Уменьшает длину строки и обновляет завершающий символ.

### void clear()
- Очищает строку, устанавливая длину равной `0`.
    - Перед модификацией вызывает `make_copy()`.
    - Не освобождает выделенную память.

### void shrink_to_fit()
- Если ёмкость превышает длину строки (с учетом служебной информации), вызывает `reallocate()` для уменьшения объема выделенной памяти.

### CowString& operator+=(char symbol)
- Добавляет символ к строке, делегируя вызов методу `push_back()`.

### CowString& operator+=(const CowString& other)
- Конкатенирует строку `other` в конец текущей строки.
    - При необходимости, вызывает `make_copy()` или `reallocate()` для обеспечения достаточной ёмкости.
    - Копирует данные с использованием `std::copy`.
    - Обновляет длину и записывает завершающий символ `\0`.

### void swap(CowString& other)
- Обменивает данные текущего объекта с объектом `other` с использованием `std::swap`.

### CowString substr(size_t start, size_t length) const
- Возвращает подстроку, начиная с позиции `start` и содержащую не более `length` символов.
- Использует приватный конструктор для создания нового объекта.

### CowString& operator=(const CowString& other)
- Присваивает значение `other` текущему объекту.
    - Если объекты ссылаются на один и тот же буфер, операция не выполняется.
    - Иначе, создаётся временная копия и данные обмениваются через метод `swap()`.

---

## Вспомогательные методы

### void make_copy()
- Обеспечивает уникальное владение буфером.
- Если счётчик ссылок больше `1`, вызывает `reallocate()` для создания копии данных.

### bool is_alone()
- Возвращает `true`, если объект владеет буфером эксклюзивно (счётчик ссылок равен `1`).

### size_t& get_buffer_counter() const
- Возвращает ссылку на счётчик ссылок, находящийся в служебной области буфера.

### void reallocate(size_t length)
- Перевыделяет память для строки.
    - Уменьшает счётчик ссылок текущего буфера.
    - Выделяет новый блок памяти размером `length`.
    - Копирует содержимое старого буфера с использованием `std::copy`.
    - Если старый буфер не используется, освобождает память.
    - Обновляет внутренние переменные, устанавливая счётчик ссылок в `1`.

### std::tuple<char*, size_t, size_t> get_string_info() const
- Возвращает кортеж, содержащий указатель на буфер, ёмкость и длину строки.

---

## Нестатические операторы

### operator<(const CowString& lhs, const CowString& rhs)
- Лексикографическое сравнение строк:
    - Сравнивает первые `min(lhs.length(), rhs.length())` символов с использованием `memcmp`.
    - При равенстве, сравнивает длины строк.

### operator>=(const CowString& lhs, const CowString& rhs)
- Возвращает результат отрицания выражения `(lhs < rhs)`.

### operator<=(const CowString& lhs, const CowString& rhs)
- Равносильно выражению `(rhs >= lhs)`.

### operator>(const CowString& lhs, const CowString& rhs)
- Возвращает результат отрицания выражения `(lhs <= rhs)`.

### operator==(const CowString& lhs, const CowString& rhs)
- Возвращает `true`, если строки имеют равную длину и идентичное содержимое (сравнение с использованием `memcmp`).

### operator!=(const CowString& lhs, const CowString& rhs)
- Равносильно отрицанию оператора `==`.

### operator+(const CowString& lhs, const CowString& rhs)
- Возвращает новый объект, являющийся конкатенацией `lhs` и `rhs`.
    - Создаёт копию `lhs`, затем вызывает оператор `+=` с `rhs`.

### operator>>(std::istream& inStream, CowString& other)
- Считывает строку из потока ввода в объект `other`.
    - Очищает `other` с помощью `clear()`.
    - Считывает символы, игнорируя начальные пробельные символы.
    - Прекращает чтение при встрече пробела (после начала ввода) или EOF.
    - Добавляет каждый считанный символ через `push_back()`.

### operator<<(std::ostream& outStream, const CowString& str)
- Выводит содержимое объекта `str` в поток `outStream`, последовательно передавая каждый символ.

---
## Пример использования
```
#include "string.h"
#include <iostream>

int main() {
    CowString s1("Example");
    CowString s2 = s1; // Копирование с использованием COW (счетчик ссылок увеличивается)
    s1.push_back('!');

    std::cout << "s1: " << s1 << "\n"; // Вывод: "Example!"
    std::cout << "s2: " << s2 << "\n"; // Вывод: "Example"

    if (s1 != s2)
        std::cout << "Строки различаются\n";

    CowString s3 = s1.substr(0, 4); // "Exam"
    std::cout << "s3: " << s3 << "\n";

    return 0;
}

```