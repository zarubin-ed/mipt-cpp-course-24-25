# Deque Template Class (`deque.h`)

Шаблонный класс `Deque<T>` — двусторонняя очередь (deque) с поддержкой случайного доступа, реализованная через фиксированные блоки (buckets). Предоставляет полный интерфейс контейнера: итераторы, индексирование, вставку/удаление в начале и конце, произвольное вставление/удаление и др.

---

## Содержание
1. [Общая концепция](#overview)
2. [Структура данных](#structure)
3. [Конструкторы и деструктор](#constructors)
4. [Итераторы](#iterators)
5. [Основные методы](#methods)
6. [Операторы](#operators)
7. [Вставка и удаление](#modifiers)
8. [Пример использования](#example)

---

## <a name="overview"></a>1. Общая концепция

`Deque<T>` хранит элементы в последовательности фиксированных блоков (buckets) размером `Bucket::kBucketSize`. Такой подход позволяет эффективно добавлять/удалять элементы и поддерживать случайный доступ за амортизированное O(1).

- **Случайный доступ**: `operator[]`, `at()` — O(1)
- **Добавление/удаление в конец/начало**: `push_back`, `pop_back`, `push_front`, `pop_front` — амортизированное O(1)
- **Вставка/удаление в середину**: O(n)
- **Итераторы**: поддерживают все операции случайного доступа

---

## <a name="structure"></a>2. Структура данных

- `Bucket` — вложенный класс, содержит выровненный блок памяти под `kBucketSize` объектов `T`.
- Поля `Deque<T>`:
  - `Bucket* data_` — массив `numberOfBuckets_ + 1` бакетов.
  - `size_t size_` — текущее число элементов.
  - `size_t numberOfBuckets_` — число задействованных бакетов.
  - `iterator begin_` — итератор на первый элемент.

Каждый бакет выделяется вручную через `operator new` с выравниванием.

---

## <a name="constructors"></a>3. Конструкторы и деструктор

| Сигнатура | Описание |
|---|---|
| `Deque()` | Пустая дека
| `Deque(const Deque& other)` | Копирующий: выделяет новые бакеты и копирует элементы
| `Deque(size_t n)` | Конструирует `n` дефолтных элементов `T()`
| `Deque(size_t n, const T& value)` | `n` копий `value`
| `~Deque()` | Вызывает деструкторы элементов и освобождает бакеты

---

## <a name="iterators"></a>4. Итераторы

Шаблонный вложенный класс `Iterator<IsConst>`:
- Поддерживает `RandomAccessIterator`
- Операции: `++`, `--`, `+`, `-`, `+=`, `-=`
- Разыменование: `*`, `->`, `operator[]`
- Сравнение: `<=>`, `==`

Типы:
```cpp
auto it = deque.begin();            // iterator
auto cit = deque.cbegin();          // const_iterator
auto rit = deque.rbegin();          // reverse_iterator
````

---

## <a name="methods"></a>5. Основные методы

| Метод           | Сигнатура               | Описание                     | Сложность    |
| --------------- | ----------------------- | ---------------------------- | ------------ |
| `size()`        | `size_t size() const`   | Количество элементов         | O(1)         |
| `empty()`       | `bool empty() const`    | Пусто?                       | O(1)         |
| `operator[](i)` | `T& operator[](size_t)` | Случайный доступ             | O(1)         |
| `at(i)`         | `T& at(size_t)`         | Случайный доступ с проверкой | O(1), throws |
| `front()`       | `T& front()`            | Первый элемент               | O(1)         |
| `back()`        | `T& back()`             | Последний элемент            | O(1)         |

---

## <a name="operators"></a>6. Операторы

| Оператор                       | Описание                                 |
| ------------------------------ | ---------------------------------------- |
| `operator=`                    | Присваивание (copy-and-swap)             |
| `operator[]`                   | Индексирование                           |
| `operator==, !=, <, >, <=, >=` | Для итераторов и элементов при сравнении |

---

## <a name="modifiers"></a>7. Вставка и удаление

| Метод                  | Сигнатура               | Описание       | Сложность |
| ---------------------- | ----------------------- | -------------- | --------- |
| `push_back(const T&)`  | Добавить в конец        | Amortized O(1) |           |
| `pop_back()`           | Удалить с конца         | O(1)           |           |
| `push_front(const T&)` | Добавить в начало       | Amortized O(1) |           |
| `pop_front()`          | Удалить с начала        | O(1)           |           |
| `insert(pos, value)`   | Вставить перед `pos`    | O(n)           |           |
| `erase(pos)`           | Удалить элемент в `pos` | O(n)           |           |
| `swap(other)`          | Поменять содержимое     | O(1)           |           |

---

## <a name="example"></a>8. Пример использования

```cpp
#include "deque.h"
#include <iostream>

int main() {
  Deque<int> dq;
  dq.push_back(1);
  dq.push_front(0);
  dq.push_back(2);

  for (auto x : dq) std::cout << x << " ";  // 0 1 2
  std::cout << "\nSize: " << dq.size() << '\n';

  dq.pop_front();                           // удаляет 0
  dq.insert(dq.begin()+1, 5);               // вставляет 5 перед 2
  std::cout << dq[1];                       // 5

  dq.erase(dq.begin());                     // удаляет 1
  for (auto it = dq.rbegin(); it != dq.rend(); ++it)
    std::cout << *it << " ";               // 2 5
}
```